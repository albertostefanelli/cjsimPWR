#' Evaluate conjoint process of profile selection
#' @description Analysis the conjoint process of profile selection and
#' @param input dataframe with treatment variables generated by sim_to_long(), i.e. long conjoint format
#' @return
#' - est_coef: estimated coefficient
#' - est_se: estimated standard error
#' - true_coef: coefficient from true_coefs
#' - sig: logical, if the est_coef was significant (alpha = 0.05)
#' - in_ci95: logical, if the true_coef was in the CI95
#' - typeS: logical, did the sign of sig. coef match to true?
#' - typeM: ratio of estimated/true, if significant (for typeS and typeM, see Gelman and Carlin, 2014)
#' @export
#'
#' @examples

evaluate_model <- function(input,
                           robust=TRUE){

  num_respondents <- sum(input$inputs$units)
  num_tasks <- length(unique(input$data$task))
  num_attrbs <- sum(str_detect(names(input$data), "var_"))

  # if id_grp is not in input = no subgrups aka only 1 population
  if (!"id_grp" %in% names(input$data)){grps_num <- 1} else{
    grps_num <- length(unique(input$data$id_grp))
  }

  if (grps_num == 1){

    # model formula
    model_formula <- as.formula(paste("y ~", paste0("var_", 1:num_attrbs, collapse= " + " )))
    # LPM using GLM gaussian family
    mod <- glm(model_formula, data = input$data,
               family=gaussian(link="identity"))

    # estimated effect w non-robust std.error
    mm_noclust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs),  p_adjust=NULL) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(-contrast) |>
      select(!starts_with("predicted"))

    #  estimated effect w cluster-robust std.error
    mm_robust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs),  p_adjust=NULL, vcov = ~ id) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(std.error, term, n_coef, conf.low, conf.high)  |>
      rename(`std.error.robust` = std.error,
             `conf.low.robust` = conf.low,
             `conf.high.robust` = conf.high
      )
      #mutate_at(vars(conf.low.robust, conf.high.robust), ~round(.x, 3))

    # join the marginal effect w non-robust std.error w cluster-robust std.error
    mm <- left_join(mm_noclust, mm_robust, by=c("term","n_coef" ))

    # match the true_coef value with the estimated effects in the mm table
    df_loop <- c()
    # length of the list of input = number of attributes
    for (c in 1:length(input$input$true_coef) ) {
      # rename attributes to match the model formula
      term <- paste0("var_", c)
      # number of levels of each attribute
      for (levels in 1:length(input$input$true_coef[[c]])) {
        # extract true_coef [[attribute]][[level]]
        n_coef <- levels
        true_coef <-  input$input$true_coef[[c]][[levels]]
        df_loop[[paste(term,n_coef)]] <- data.frame(term, n_coef, true_coef)
      }

    }

    # rbind the true_coef dataframe
    df_bid <- do.call(rbind, df_loop)

    # merge true_coef with estimated effect by attribute and level
    mm <- left_join(mm,df_bid, by=c("term","n_coef"))
  }else{

    # model formula with interaction between attributes and id_grp (i.e., sub-population indicator)
    model_formula <- as.formula(paste("y ~", paste0("var_", 1:num_attrbs, "*id_grp" , collapse= " + " )))
    # LPM using GLM gaussian family
    mod <- glm(model_formula, data = input$data,
               family=gaussian(link="identity"))

    # estimated effect w non-robust std.error
    mm_noclust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs), by = "id_grp",  p_adjust=NULL) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(!starts_with("predicted"))

    #  estimated effect w cluster-robust std.error
    mm_robust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs), by = "id_grp",  p_adjust=NULL, vcov = ~ id) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(id_grp, std.error, term, n_coef,conf.low, conf.low, conf.high)  |>
      rename(`std.error.robust` = std.error,
             `conf.low.robust` = conf.low,
             `conf.high.robust` = conf.high
      ) #|>
     # mutate_at(vars(conf.low.robust, conf.high.robust), ~ round(.x, 3))

    # join the marginal effect w non-robust std.error w cluster-robust std.error
    mm <- left_join(mm_noclust, mm_robust, by=c("id_grp","term","n_coef" ))

    # match the true_coef value with the estimated effects obtained from the simulated data
    df_loop <- c()
    # length of subgroups (i.e., populations) in the simulated data
    for (n in names(input$input$true_coef)){
      id_grp <- n
      # length of the list of input = number of attributes
      for (c in 1:length(input$input$true_coef[[n]])) {
        # rename attributes to match the model formula
        term <- paste0("var_", c)
        # number of levels of each attribute
        for (levels in 1:length(input$input$true_coef[[n]][[c]])) {
          n_coef <- levels
          # extract true_coef [[subpopulation]][[attribute]][[level]]
          true_coef <-  input$input$true_coef[[n]][[c]][levels]
          df_loop[[paste(id_grp, term, n_coef)]] <- data.frame(id_grp, term, n_coef, true_coef)
        }

      }
    }

    # rbind the true_coef dataframe
    df_bid <- do.call(rbind, df_loop)

    # merge true_coef with estimated effect by subpopulation, attribute, level
    mm <- left_join(mm,df_bid, by=c("id_grp","term","n_coef"))

  }

  # Check whether the estimate is in CI95: results to T or F

  # if the estimate is within the CI we say that there is an effect in the population SO that there is difference (effect) when there is a difference (effect)
  # if we get smaller CI (in our case increasing alpha from 0.001 to 0.1 [HIGHER ALPHA]) we DECREASE the chances that the estimate is inside the CI SO that there is difference (effect) when there is a difference (effect)
  # SO this means that we decrease the probability of finding an effect that is there that MEANS LOWER POWER that means higher type II erorr.
  # SO this means that we reduce the chances of saying that there is a difference (effect) when there is not. this means reducing Type I error.
  #HOWEVER WE NEED THE OPPSITITE

  #increasing Î± (e.g., from .01 to .05 or .10) increases the chances of making a Type I Error (i.e., saying there is a difference when there is not)
  #decreases the chances of making a Type II Error (i.e., saying there is no difference when there is) [SO HIGHER POWER]
  #and decreases the rigor of the test.

  # setting alpha for calculating power and significant level
  alpha <- 0.05
  z_score <- qnorm(1 - alpha/2)
  # Is significant?

  mm$sig <- ifelse(abs(mm$estimate /  mm$std.error) > z_score, T, F)

  mm$sig_robust <- ifelse(abs(mm$estimate /  mm$std.error.robust) > z_score, T, F)


  # Confidence intervals
  mm$ci_lower <- mm$estimate - z_score * mm$std.error
  mm$ci_upper <- mm$estimate + z_score * mm$std.error

  mm$ci_robust_lower <- mm$estimate - z_score * mm$std.error.robust
  mm$ci_robust_upper <- mm$estimate + z_score * mm$std.error.robust


  # IF sig, is within the CI?
  mm$in_ci <- ifelse(mm$sig, ifelse(mm$true_coef < ci_upper &
                                        mm$true_coef > ci_lower,
                                      T, F), F)

  mm$in_ci_robust <- ifelse(mm$sig_robust,ifelse(mm$true_coef < ci_robust_upper &
                                                     mm$true_coef > ci_robust_lower,
                                                   T, F), F)

  # If significant, Type S
  mm$typeS <- ifelse(mm$sig, ifelse(sign(mm$estimate) == sign(mm$true_coef),
                                    F, T), NA)

  mm$typeS_robust <- ifelse(mm$sig_robust, ifelse(sign(mm$estimate) == sign(mm$true_coef),
                                                  F, T), NA)

  # # If significant, Type M
  mm$typeM <- ifelse(mm$sig, mm$estimate / mm$true_coef, NA)

  mm$typeM_robust <- ifelse(mm$sig_robust, mm$estimate / mm$true_coef, NA)

  # inputs to be passed to the result obj
  mm$num_respondents <- num_respondents
  mm$num_attrbs <- num_attrbs
  mm$num_tasks <- num_tasks
  mm$grps_num <- grps_num

  mm <- mm %>% rename(`level` = `n_coef`,
                      `attrb` = `term`
  )


  if (grps_num == 1){
    if(roubust){
    # robust results wo sub populations
    result <-  mm |> select(
                    # design
                    num_respondents, num_attrbs, num_tasks,
                    # attributes and levels
                    attrb, level,
                    # estimation
                    true_coef, estimate, std.error.robust,
                    ci_robust_lower, ci_robust_upper,
                    # evaluation
                    in_ci_robust,
                    sig_robust,
                    typeS_robust,
                    typeM_robust)}else{
    # robust results w sub populations
    result <-  mm |> select(
                   # design
                    num_respondents, num_attrbs, num_tasks,
                    # attributes and levels
                    attrb, level,
                    # estimation
                    true_coef, estimate, std.error,
                    ci_lower, ci_upper,
                    # evaluation
                    in_ci,
                    sig,
                    typeS,
                    typeM)}

    }else{
      if(roubust){
      # robust results wo sub populations
    result <-  mm |> select(
        # design
        num_respondents, num_attrbs, num_tasks,
        # sub population, attributes and levels
        id_grp, attrb, level,
        # estimation
        true_coef, estimate, std.error.robust,
        ci_robust_lower, ci_robust_upper,
        # evaluation
        in_ci_robust,
        sig_robust,
        typeS_robust,
        typeM_robust)}else{
       # non-robust results w sub populations
    result <-  mm |> select(
          # design
          num_respondents, num_attrbs, num_tasks,
          # sub population, attributes and levels
          id_grp, attrb, level,
          # estimation
          true_coef, estimate, std.error,
          ci_lower, ci_upper,
          # evaluation
          in_ci,
          sig,
          typeS,
          typeM)}}

  results <- result |> mutate_if(is.numeric, ~format(round(.x,digits=2), nsmall=2))

  return(result)
}
