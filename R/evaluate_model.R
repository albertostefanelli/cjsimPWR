#' Evaluate the simulated conjoint process of profile selection against the hypothesized true coefficients.
#' @description Analysis the conjoint process of profile selection.
#' @param input lost; a list containing (a) a dataframe with the simulated data in long format generated by sim_to_long() and (b) a list of inputs that represents the design specifications.
#' @param robust logical; whether the evaluation should be use cluster (id) robust standard error. Default is set to TRUE.
#' @return
#' - num_respondents: int; total number or respondents.
#' - num_attrbs: int; total number of attributes included in the conjoint experiment.
#' - num_tasks: int; total number of task taken by each respondent.
#' - id_grp: character; name of the sub-population of interest.
#' - attrb: int; name of the attribute included in the conjoint design. At the moment these cannot be changed and are in the format var_1 ... var_x.
#' - level: int; levels of each attribute.
#' - true_coef: numeric; coefficient from true_coefs.
#' - estimate: numeric; estimated coefficient from the linear probability model .
#' - std.error[.robust]: numeric; estimated (robust) standard error.
#' - ci[_robust]_lower: numeric; lower bound of the confidence interval calculated (level= 0.95).
#' - ci[_robust]_upper: numeric;upper bound of the confidence interval calculated (level= 0.95).
#' - in_ci[_robust]: logical, if the true_coef is contained in the confidence level.
#' - sig[_robust]: logical, if the estimate coefficent (estimate) is significant (alpha = 0.05).
#' - typeS[_robust]: logical, did the sign of sig. coef match to true? (see, Gelman and Carlin, 2014).
#' - typeM[_robust]: numeric; ratio of estimated/true coefficent, if significant (see Gelman and Carlin, 2014).
#' @export
#'
#' @examples
#' # Conjoint design with 3 attributes with 2, 3, 5 levels respectively
#' design_example <- generate_design(n_profiles = 2,
#'  n_attributes = 3,
#'  n_levels = c(2, 3, 5))
#'
#' # Design with multiple groups/sub-populations:
#' # random sample of 500 Democratic, 200 Independent, 500 Republican respondents
#' sample_subgrp <- generate_samples(design =  list(design_example, design_example, design_example),
#'                                units = c(500, 200, 500),
#'                                n_tasks = c(3, 3, 3),
#'                                group_name = c("Democrat","Independent", "Republican" )
#'                                )
#'
#' # Simulated data using the coefficients contained in true_coef for each subgroup of respondents
#' simulated_cj <- simulate_conjoint(sample_subgrp,
#'             true_coef = list("Democrat" = list(0.2, c(-0.1, 0.1), c(-0.1, -0.1, -0.1, 0.1)),
#'                              "Independent" = list(0.1, c(-0.2, -0.05),  c(-0.1, 0.1, 0.1, 0.3)),
#'                              "Republican" = list(0.1, c(-0.1, 0.05),  c(-0.1, 0.2, -0.1, 0.1))),
#'            sigma.u_k = 0.05,
#'            LOG = FALSE)
#'
#' # Transform the dataframe obtained from simulate_conjoint() in a long format
#' simulated_cj_long <- sim_to_long(simulated_cj)
#' # Evaluate the conjoint process of profile selection against the hypothesized true coefficients.
#' evaluate <- evaluate_model(simulated_cj_long)
#'

evaluate_model <- function(input,
                           robust=TRUE){

  num_respondents <- sum(input$inputs$units)
  num_tasks <- length(unique(input$data$task))
  num_attrbs <- sum(str_detect(names(input$data), "var_"))

  # if id_grp is not in input = no subgrups aka only 1 population
  if (!"id_grp" %in% names(input$data)){grps_num <- 1} else{
    grps_num <- length(unique(input$data$id_grp))
  }

  if (grps_num == 1){

    # model formula
    model_formula <- as.formula(paste("y ~", paste0("var_", 1:num_attrbs, collapse= " + " )))
    # LPM using GLM gaussian family
    mod <- glm(model_formula, data = input$data,
               family=gaussian(link="identity"))

    # TO DO: remove the pipes to make the package compatible with older R versions
    # estimated effect w non-robust std.error
    mm_noclust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs),  p_adjust=NULL) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(-contrast) |>
      select(!starts_with("predicted"))

    #  estimated effect w cluster-robust std.error
    mm_robust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs),  p_adjust=NULL, vcov = ~ id) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(std.error, term, n_coef, conf.low, conf.high)  |>
      rename(`std.error.robust` = std.error,
             `conf.low.robust` = conf.low,
             `conf.high.robust` = conf.high
      )

    # join the marginal effect w non-robust std.error w cluster-robust std.error
    mm <- left_join(mm_noclust, mm_robust, by=c("term","n_coef" ))

    # match the true_coef value with the estimated effects in the mm table
    df_loop <- c()
    # length of the list of input = number of attributes
    for (c in 1:length(input$input$true_coef) ) {
      # rename attributes to match the model formula
      term <- paste0("var_", c)
      # number of levels of each attribute
      for (levels in 1:length(input$input$true_coef[[c]])) {
        # extract true_coef [[attribute]][[level]]
        n_coef <- levels
        true_coef <-  input$input$true_coef[[c]][[levels]]
        df_loop[[paste(term,n_coef)]] <- data.frame(term, n_coef, true_coef)
      }

    }

    # rbind the true_coef dataframe
    df_bid <- do.call(rbind, df_loop)

    # merge true_coef with estimated effect by attribute and level
    mm <- left_join(mm,df_bid, by=c("term","n_coef"))
  }else{

    # model formula with interaction between attributes and id_grp (i.e., sub-population indicator)
    model_formula <- as.formula(paste("y ~", paste0("var_", 1:num_attrbs, "*id_grp" , collapse= " + " )))
    # LPM using GLM Gaussian family
    mod <- glm(model_formula, data = input$data,
               family=gaussian(link="identity"))

    # estimated effect w non-robust std.error
    mm_noclust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs), by = "id_grp",  p_adjust=NULL) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(!starts_with("predicted"))

    #  estimated effect w cluster-robust std.error
    mm_robust <- marginaleffects::avg_slopes(mod, variables = paste0("var_", 1:num_attrbs), by = "id_grp",  p_adjust=NULL, vcov = ~ id) |>
      data.frame() |>
      mutate(n_coef = gsub("^(.*?)-.*$", "\\1", contrast)) |>
      mutate(n_coef = gsub("[^0-9.]", "", n_coef)) |>
      mutate(n_coef = as.numeric(n_coef)) |>
      select(id_grp, std.error, term, n_coef,conf.low, conf.low, conf.high)  |>
      rename(`std.error.robust` = std.error,
             `conf.low.robust` = conf.low,
             `conf.high.robust` = conf.high
      )

    # join the marginal effect w non-robust std.error w cluster-robust std.error
    mm <- left_join(mm_noclust, mm_robust, by=c("id_grp","term","n_coef" ))

    # match the true_coef value with the estimated effects obtained from the simulated data
    df_loop <- c()
    # length of subgroups (i.e., populations) in the simulated data
    for (n in names(input$input$true_coef)){
      id_grp <- n
      # length of the list of input = number of attributes
      for (c in 1:length(input$input$true_coef[[n]])) {
        # rename attributes to match the model formula
        term <- paste0("var_", c)
        # number of levels of each attribute
        for (levels in 1:length(input$input$true_coef[[n]][[c]])) {
          n_coef <- levels
          # extract true_coef [[subpopulation]][[attribute]][[level]]
          true_coef <-  input$input$true_coef[[n]][[c]][levels]
          df_loop[[paste(id_grp, term, n_coef)]] <- data.frame(id_grp, term, n_coef, true_coef)
        }

      }
    }

    # rbind the true_coef dataframe
    df_bid <- do.call(rbind, df_loop)

    # merge true_coef with estimated effect by subpopulation, attribute, level
    mm <- left_join(mm,df_bid, by=c("id_grp","term","n_coef"))

  }

  # TO DO: implement a way to use alpha to check whether the estimate is within CI
  # if we get smaller CI ("HIGHER ALPHA") we DECREASE the chances that the estimate is inside the CI
  # ---->  lower probability of finding an effect that is there
  # ---->  lower power AND higher type II error.
  # ---->  lower chances of saying that there is a difference (effect) when there is not.
  # ---->  reducing Type I error.

  # HOWEVER: in traditional power analysis increasing alpha does the oppsite:
  # ----> increases the chances of making a Type I Error (i.e., saying there is a difference when there is not)
  # ----> decreases the chances of making a Type II Error (i.e., saying there is no difference when there is) [SO HIGHER POWER AND LOWER RIGOR OF THE TEST]

  # setting alpha for calculating power and significant level
  # TO DO: implement varying alpha for allowing trade-off between type 1 and type 2 errors
  alpha <- 0.05
  z_score <- qnorm(1 - alpha/2)

  # Is significant?
  mm$sig <- ifelse(abs(mm$estimate /  mm$std.error) > z_score, T, F)
  mm$sig_robust <- ifelse(abs(mm$estimate /  mm$std.error.robust) > z_score, T, F)

  # Confidence intervals
  mm$ci_lower <- mm$estimate - z_score * mm$std.error
  mm$ci_upper <- mm$estimate + z_score * mm$std.error

  mm$ci_robust_lower <- mm$estimate - z_score * mm$std.error.robust
  mm$ci_robust_upper <- mm$estimate + z_score * mm$std.error.robust

  # IF sig, is within the CI? [not used atm]
  mm$in_ci <- ifelse(mm$sig, ifelse(mm$true_coef <  mm$ci_upper &
                                        mm$true_coef >  mm$ci_lower,
                                      T, F), F)

  mm$in_ci_robust <- ifelse(mm$sig_robust,ifelse(mm$true_coef <  mm$ci_robust_upper &
                                                     mm$true_coef >  mm$ci_robust_lower,
                                                   T, F), F)

  # If significant, Type S
  mm$typeS <- ifelse(mm$sig, ifelse(sign(mm$estimate) == sign(mm$true_coef),
                                    F, T), NA)

  mm$typeS_robust <- ifelse(mm$sig_robust, ifelse(sign(mm$estimate) == sign(mm$true_coef),
                                                  F, T), NA)

  # # If significant, Type M
  mm$typeM <- ifelse(mm$sig, mm$estimate / mm$true_coef, NA)
  mm$typeM_robust <- ifelse(mm$sig_robust, mm$estimate / mm$true_coef, NA)

  # inputs to be passed to the result obj
  mm$num_respondents <- num_respondents
  mm$num_attrbs <- num_attrbs
  mm$num_tasks <- num_tasks
  mm$grps_num <- grps_num

  mm <- mm |> rename(`level` = `n_coef`,
                      `attrb` = `term`
  )

  if (grps_num == 1){
    if(robust){
    # robust results wo sub populations
    result <-  mm |> select(
                    # design
                    num_respondents, num_attrbs, num_tasks,
                    # attributes and levels
                    attrb, level,
                    # estimation
                    true_coef, estimate, std.error.robust,
                    ci_robust_lower, ci_robust_upper,
                    # evaluation
                    in_ci_robust,
                    sig_robust,
                    typeS_robust,
                    typeM_robust)}else{
    # robust results w sub populations
    result <-  mm |> select(
                   # design
                    num_respondents, num_attrbs, num_tasks,
                    # attributes and levels
                    attrb, level,
                    # estimation
                    true_coef, estimate, std.error,
                    ci_lower, ci_upper,
                    # evaluation
                    in_ci,
                    sig,
                    typeS,
                    typeM)}

    }else{
      if(robust){
    # robust results wo sub populations
    result <-  mm |> select(
        # design
        num_respondents, num_attrbs, num_tasks,
        # sub population, attributes and levels
        id_grp, attrb, level,
        # estimation
        true_coef, estimate, std.error.robust,
        ci_robust_lower, ci_robust_upper,
        # evaluation
        in_ci_robust,
        sig_robust,
        typeS_robust,
        typeM_robust)}else{
    # non-robust results w sub populations
    result <-  mm |> select(
          # design
          num_respondents, num_attrbs, num_tasks,
          # sub population, attributes and levels
          id_grp, attrb, level,
          # estimation
          true_coef, estimate, std.error,
          ci_lower, ci_upper,
          # evaluation
          in_ci,
          sig,
          typeS,
          typeM)}
      }

  results <- result |> mutate_if(is.numeric, ~format(round(.x,digits=2), nsmall=2))

  return(result)
}
